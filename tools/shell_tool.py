import asyncio
import json
import logging
import platform
import queue
import time
import traceback
import warnings
from typing import Any, Dict, List, Optional, Type, Union

from fastapi import WebSocket
from fastapi.websockets import WebSocketState
from langchain_core.callbacks import (
    CallbackManagerForToolRun,
)
from langchain.callbacks.base import BaseCallbackHandler
from langchain_core.pydantic_v1 import BaseModel, Field, root_validator
from langchain_core.tools import BaseTool


logger = logging.getLogger(__name__)


class ShellInput(BaseModel):
    """Commands for the Bash Shell tool."""

    commands: Union[str, List[str]] = Field(
        ...,
        description="List of shell commands to run. Deserialized using json.loads",
    )
    """List of shell commands to run."""

    @root_validator(pre=True)
    def _validate_commands(cls, values: dict) -> dict:
        """Validate commands."""
        # TODO: Add real validators
        commands = values.get("commands")
        if not isinstance(commands, list):
            values["commands"] = [commands]
        # Warn that the bash tool is not safe
        warnings.warn(
            "The shell tool has no safeguards by default. Use at your own risk."
        )
        return values



def _get_platform() -> str:
    """Get platform."""
    system = platform.system()
    if system == "Darwin":
        return "MacOS"
    return system


class ShellTool(BaseTool):
    """Tool to run shell commands."""

    name: str = "terminal"
    """Name of tool."""

    description: str = f"Run shell commands on this {_get_platform()} machine. "
    """Description of tool."""

    args_schema: Type[BaseModel] = ShellInput
    """Schema for input arguments."""

    ask_human_input: bool = False
    """
    If True, prompts the user for confirmation (y/n) before executing 
    a command generated by the language model in the bash shell.
    """

    ws_con: WebSocket = None

    ws_message_queue: queue.Queue = None

    def __init__(self, ws: WebSocket, ws_message_queue: queue.Queue, callbacks: List[BaseCallbackHandler]):
        super().__init__()
        self.ws_con = ws
        self.ws_message_queue = ws_message_queue
        self.callbacks = callbacks

    def _run(
        self,
        commands: Union[str, List[str]],
        run_manager: Optional[CallbackManagerForToolRun] = None,
    ) -> str:
        """Run commands and return final output."""

        print(f"Executing command:\n {commands}")  # noqa: T201

        try:
            if self.ask_human_input:
                user_input = input("Proceed with command execution? (y/n): ").lower()
                if user_input == "y":
                    return self._runrun(commands)
                else:
                    logger.info("Invalid input. User aborted command execution.")
                    return None  # type: ignore[return-value]
            else:
                return self._runrun(commands)

        except Exception as e:
            logger.error(f"Error during command execution: {e}")
            return None  # type: ignore[return-value]

    
    def _runrun(self, command: str) -> str:
        """
        Runs a command in a subprocess and returns
        the output.

        Args:
            command: The command to run
        """
        try:
            asyncio.run(self.ws_con.send_json({ "command" : command }))
            print(f"Command sent. { { "command" : command } }")
            for _ in range(60):
                print(f"Shell tool wait for command response. count:{_}")
                if not self.ws_message_queue.empty():
                    break
                if self.ws_con.application_state != WebSocketState.CONNECTED:
                    self.ws_message_queue.put("")
                    break
                time.sleep(1)
            output: Dict[str, str] = self.ws_message_queue.get()
            print(f"Command response recived. f{output}")

            return f"{output['stdout']}\n{output['stderr']}"
        
        except:
            traceback.print_exc()
    # def _runrun(self, command: str) -> str:
    #     """
    #     Runs a command in a subprocess and returns
    #     the output.

    #     Args:
    #         command: The command to run
    #     """
    #     try:
    #         output = subprocess.run(
    #             command,
    #             shell=True,
    #             check=True,
    #             stdout=subprocess.PIPE,
    #             stderr=subprocess.STDOUT,
    #         ).stdout.decode()
    #     except subprocess.CalledProcessError as error:
    #         return error.stdout.decode()
    #     return output
